(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Trixie = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Effect = function () {
	function Effect(shaderString, uniforms) {
		_classCallCheck(this, Effect);

		this.shaderString = shaderString;
		this.uniforms = uniforms;
		this.uniformLocations = {};
		this.uniformsNeedUpdate = true;
		this.shaderProgram = null;
		this.enabled = true;
	}

	_createClass(Effect, [{
		key: "createShaderProgram",
		value: function createShaderProgram(gl) {
			var _this = this;

			if (this.shaderProgram !== null) return;
			var vertexShader = "\n\t\t\tprecision highp float;\n\t\t\tin vec2 position;\n\t\t\tin vec2 coord;\n\t\t\tout vec2 texCoord;\n\t\t\tuniform vec2 resolution;\n\t\t\tvoid main() {\n\t\t\t\ttexCoord = coord;\n\t\t\t\tgl_Position = vec4(position/resolution * 2.0 - 1.0, 0.0, 1.0);\n\t\t\t}\n\t\t";
			var vs = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vs, "#version 300 es\n" + vertexShader);
			gl.compileShader(vs);
			var fs = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fs, "#version 300 es\n" + this.shaderString);
			gl.compileShader(fs);
			var error = gl.getShaderInfoLog(fs);
			if (error) console.error(error);
			this.shaderProgram = gl.createProgram();
			gl.attachShader(this.shaderProgram, vs);
			gl.attachShader(this.shaderProgram, fs);
			gl.linkProgram(this.shaderProgram);
			// gl.useProgram(this.program);
			this.uniformLocations.time = gl.getUniformLocation(this.shaderProgram, "time");
			this.uniformLocations.resolution = gl.getUniformLocation(this.shaderProgram, "resolution");
			this.uniformLocations.texture = gl.getUniformLocation(this.shaderProgram, "texture");
			Object.keys(this.uniforms).forEach(function (name) {
				_this.uniformLocations[name] = gl.getUniformLocation(_this.shaderProgram, name);
			});
		}
	}, {
		key: "getParameter",
		value: function getParameter(x) {
			return this.uniforms[x];
		}
	}, {
		key: "setParameter",
		value: function setParameter(x, value) {
			this.uniforms[x] = value;
			this.uniformsNeedUpdate = true;
		}
	}]);

	return Effect;
}();

exports.default = Effect;

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _effect = require("./effect.js");

var _effect2 = _interopRequireDefault(_effect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
	identity: function identity() {
		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tvoid main() {\n\t\t\t\tfragColor = texture(tex, texCoord);\n\t\t\t}\n\t\t", {});
	},
	invert: function invert() {
		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tvoid main() {\n\t\t\t\tvec4 color = texture(tex, texCoord);\n\t\t\t\tfragColor = vec4(vec3(1.0 - color.rgb), color.a);\n\t\t\t}\n\t\t", {});
	},
	horizontalFlip: function horizontalFlip() {
		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tvoid main() {\n\t\t\t\tvec2 coord = vec2(1.0-texCoord.x, texCoord.y);\n\t\t\t\tvec4 color = texture(tex, coord);\n\t\t\t\tfragColor = color;\n\t\t\t}\n\t\t", {});
	},
	verticalFlip: function verticalFlip() {
		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tvoid main() {\n\t\t\t\tvec2 coord = vec2(texCoord.x, 1.0 - texCoord.y);\n\t\t\t\tvec4 color = texture(tex, coord);\n\t\t\t\tfragColor = color;\n\t\t\t}\n\t\t", {});
	},
	kaleidoscope: function kaleidoscope(_ref) {
		var rotation = _ref.rotation,
		    blades = _ref.blades,
		    scale = _ref.scale;

		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tuniform vec2 resolution;\n\t\t\tuniform float rotation;\n\t\t\tuniform float scale;\n\t\t\tuniform float blades;\n\t\t\tvec2 Kaleidoscope( vec2 uv, float n) {\n\t\t\t\tfloat PI = 3.1415926535897932384626433832795;\n\t\t\t    float angle = PI / n;\n\t\t\t    float r = length( uv );\n\t\t\t    float a = atan( uv.y, uv.x ) / angle;\n\t\t\t    a = mix( fract( a ), 1.0 - fract( a ), mod( floor( a ), 2.0 ) ) * angle;\n\t\t\t    // radial = vec2(a, r);\n\t\t\t    return vec2( cos( a ), sin( a ) ) * r;\n\t\t    }\n\t\t\tvec2 cycleUv(vec2 uv) {\n\t\t\t\tfloat x;\n\t\t\t\tfloat y;\n\t\t\t\tif (uv.x > 1.0) x = 2.0 - uv.x;\n\t\t\t\telse if (uv.x < -1.0) x = -2.0 - uv.x;\n\t\t\t\telse x = uv.x;\n\t\t\t\tif (uv.y > 1.0) y = 2.0 - uv.y;\n\t\t\t\telse if (uv.y < -1.0) y = -2.0 - uv.y;\n\t\t\t\telse y = uv.y;\n\t\t\t\treturn vec2(x, y);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tvec2 pos = vec2(0.5, 0.5);\n\t\t\t\tfloat aspect = resolution.y / resolution.x;\n\t\t\t\tvec2 uv = (texCoord.xy - 0.5) *  vec2(1.0/aspect, 1.0);\n\t\t\t\tvec2 k = Kaleidoscope(uv * mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation)), blades);\n\t\t\t\tmat2 rm = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n\t\t\t\tvec2 colour_k = rm * (k * scale + pos);\n\t\t\t\tvec4 color = texture(tex, cycleUv(colour_k));\n\t\t\t\tfragColor = color;\n\t\t\t}\n\t\t", { rotation: rotation, blades: blades, scale: scale });
	},
	zoom: function zoom(_ref2) {
		var x = _ref2.x,
		    y = _ref2.y,
		    factor = _ref2.factor;

		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tuniform float x;\n\t\t\tuniform float y;\n\t\t\tuniform float factor;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tvoid main() {\n\t\t\t\tvec2 coord = vec2((texCoord.x - x)/factor + x, (texCoord.y - y)/factor + y);\n\t\t\t\tvec4 color = texture(tex, coord);\n\t\t\t\tfragColor = color;\n\t\t\t}\n\t\t", { x: x, y: y, factor: factor });
	},
	convolve: function convolve(_ref3) {
		var kernel = _ref3.kernel;

		return new _effect2.default("\n\t\t\t#define size " + kernel.length + "\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tuniform float kernel[size];\n\t\t\tuniform vec2 resolution;\n\t\t\tfloat intmod(float a, float b) {\n\t\t\t\t\tfloat m=a-floor((a+0.5)/b)*b;\n\t\t\t\t\treturn floor(m+0.5);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tvec4 avg = vec4(0);\n\t\t\t\tint len = int(sqrt(float(size)));\n\t\t\t\tfloat total = 0.0;\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tint x = int(intmod(float(i), float(len)));\n\t\t\t\t\tint y = i / len;\n\t\t\t\t\tfloat weight = kernel[i];\n\t\t\t\t\tvec2 dp = vec2(float(x)-(float(len)-1.0)/(2.0), float(y)-(float(len)-1.0)/(2.0));\n\t\t\t\t\tavg += weight*texture(tex, texCoord + dp / resolution);\n\t\t\t\t}\n\t\t\t\tfragColor = vec4(avg.xyz, 1.0);\n\t\t\t}\n\t\t", { kernel: kernel });
	},
	verticalMirror: function verticalMirror() {
		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tvoid main() {\n\t\t\t\tfloat x;\n\t\t\t\tif (texCoord.x < 0.5) x = texCoord.x;\n\t\t\t\telse x = 1.0 - texCoord.x;\n\t\t\t\tvec4 color = texture(tex, vec2(x, texCoord.y));\n\t\t\t\tfragColor = color;\n\t\t\t}\n\t\t", {});
	},
	horizontalMirror: function horizontalMirror() {
		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tvoid main() {\n\t\t\t\tfloat y;\n\t\t\t\tif (texCoord.y < 0.5) y = texCoord.y;\n\t\t\t\telse y = 1.0 - texCoord.y;\n\t\t\t\tvec4 color = texture(tex, vec2(texCoord.x, y));\n\t\t\t\tfragColor = color;\n\t\t\t}\n\t\t", {});
	},
	colorShift: function colorShift(_ref4) {
		var phase = _ref4.phase;

		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tuniform float phase;\n\t\t\tvec3 rgb2hsv(vec3 c) {\n\t\t\t    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\t\t\t    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\t\t\t    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\t\t\t    float d = q.x - min(q.w, q.y);\n\t\t\t    float e = 1.0e-10;\n\t\t\t    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n\t\t\t}\n\t\t\tvec3 hsv2rgb(vec3 c) {\n\t\t\t    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\t\t\t    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\t\t\t    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tvec4 cin = texture(tex, texCoord);\n\t\t\t\tvec3 hsv = rgb2hsv(cin.rgb);\n\t\t\t\tvec3 cout = hsv2rgb(vec3(fract(hsv.x + phase), hsv.y, hsv.z));\n\t\t\t\tfragColor = vec4(cout, 1.0);\n\t\t\t}\n\t\t", { phase: phase });
	},
	gamma: function gamma(_ref5) {
		var value = _ref5.value;

		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tuniform float value;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tvoid main() {\n\t\t\t\tvec4 c = texture(tex, texCoord);\n\t\t\t\tfragColor = vec4(pow(c.r, value), pow(c.g, value), pow(c.b, value), c.a);\n\t\t\t}\n\t\t", { value: value });
	},
	localHistogramEqualization: function localHistogramEqualization(_ref6) {
		var width = _ref6.width,
		    bins = _ref6.bins;

		console.warn("Warning: Local histogram equalization is an experimental feature.");
		return new _effect2.default("\n\t\t\t\t#define size " + Math.round(width * width) + "\n\t\t\t\t#define bins " + Math.round(bins) + "\n\t\t\t\tprecision highp float;\n\t\t\t\tuniform float value;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform sampler2D tex;\n\t\t\t\tin vec2 texCoord;\n\t\t\t\tout vec4 fragColor;\n\t\t\t\tfloat distr[bins];\n\t\t\t\tfloat intmod(float a, float b) {\n\t\t\t\t\tfloat m=a-floor((a+0.5)/b)*b;\n\t\t\t\t\treturn floor(m+0.5);\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tint len = int(sqrt(float(size)));\n\t\t\t\t\tfloat SSE = 0.0;\n\t\t\t\t\tfloat mean = 0.0;\n\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tint x = int(intmod(float(i), float(len)));\n\t\t\t\t\t\tint y = i / len;\n\t\t\t\t\t\tvec2 dp = vec2(float(x)-(float(len)-1.0)/(2.0), float(y)-(float(len)-1.0)/(2.0));\n\t\t\t\t\t\tvec4 color = texture(tex, texCoord + dp / resolution);\n\t\t\t\t\t\tfloat gs = (color.r + color.g + color.b) / 3.0;\n\t\t\t\t\t\tint hi = int(min(float(bins)-1.0, floor(gs * float(bins))));\n\t\t\t\t\t\tdistr[hi] += 1.0/float(size);\n\t\t\t\t\t\tmean += gs / float(size);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tint x = int(intmod(float(i), float(len)));\n\t\t\t\t\t\tint y = i / len;\n\t\t\t\t\t\tvec2 dp = vec2(float(x)-(float(len)-1.0)/(2.0), float(y)-(float(len)-1.0)/(2.0));\n\t\t\t\t\t\tvec4 color = texture(tex, texCoord + dp / resolution);\n\t\t\t\t\t\tfloat gs = (color.r + color.g + color.b) / 3.0;\n\t\t\t\t\t\tSSE += (gs - mean) * (gs - mean);\n\t\t\t\t\t}\n\t\t\t\t\tvec4 c = texture(tex, texCoord);\n\t\t\t\t\tfloat gs = (c.r + c.g + c.b) / 3.0;\n\t\t\t\t\tint bin =  int(min(float(bins)-1.0, floor(gs * float(bins))));\n\t\t\t\t\tfloat fgs = 0.0;\n\t\t\t\t\tfor (int k = 0; k <= bin; k++) fgs += distr[k];\n\t\t\t\t\t// adaptation\n\t\t\t\t\tfloat var_max = (float(size) / (float(size) - 1.0)) / 16.0;\n\t\t\t\t\tfloat var = SSE / (float(size) - 1.0);\n\t\t\t\t\tfloat adaptation = var / (var_max);\n\t\t\t\t\tvec3 result = adaptation * (fgs / gs) * c.rgb + (1.0 - adaptation) * c.rgb;\n\t\t\t\t\tfragColor = vec4(result, c.a);\n\t\t\t\t}\n\t\t\t", { width: width, bins: bins });
	},
	whiteNoise: function whiteNoise(_ref7) {
		var intensity = _ref7.intensity;

		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tuniform float intensity;\n\t\t\tfloat rand(vec2 co) {\n\t\t\t\t// Source: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\t\t\t    highp float a = 12.9898;\n\t\t\t    highp float b = 78.233;\n\t\t\t    highp float c = 43758.5453;\n\t\t\t    highp float dt= dot(co.xy ,vec2(a,b));\n\t\t\t    highp float sn= mod(dt,3.14);\n\t\t\t    return fract(sin(sn) * c);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tfloat rnd = rand(texCoord);\n\t\t\t\tvec4 c = texture(tex, texCoord);\n\t\t\t\tfragColor = vec4(intensity * vec3(2.0*rnd - 1.0) + (1.0 - intensity) * c.rgb, 1.0);\n\t\t\t}\n\t\t", { intensity: intensity });
	},
	saltAndPepperNoise: function saltAndPepperNoise(_ref8) {
		var probability = _ref8.probability;

		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform float probability;\n\t\t\tuniform sampler2D tex;\n\t\t\tfloat rand(vec2 co) {\n\t\t\t\t// Source: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\t\t\t    highp float a = 12.9898;\n\t\t\t    highp float b = 78.233;\n\t\t\t    highp float c = 43758.5453;\n\t\t\t    highp float dt= dot(co.xy ,vec2(a,b));\n\t\t\t    highp float sn= mod(dt,3.14);\n\t\t\t    return fract(sin(sn) * c);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tfloat rnd1 = rand(texCoord);\n\t\t\t\tfloat rnd2 = rand(vec2(1.0, 1.0) - texCoord);\n\t\t\t\tvec4 c = texture(tex, texCoord);\n\t\t\t\tvec3 result = step(probability, rnd1) * c.rgb + (1.0 - step(probability, rnd1)) * (step(0.5, rnd2) * vec3(1, 1, 1));\n\t\t\t\tfragColor = vec4(result, c.a);\n\t\t\t}\n\t\t", { probability: probability });
	},
	adaptiveMeanFilter: function adaptiveMeanFilter(_ref9) {
		var width = _ref9.width,
		    noiseVariance = _ref9.noiseVariance;

		return new _effect2.default("\n\t\t\t#define size " + Math.round(width * width) + "\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform vec2 resolution;\n\t\t\tuniform sampler2D tex;\n\t\t\tuniform float noiseVariance;\n\t\t\tfloat intmod(float a, float b) {\n\t\t\t\tfloat m=a-floor((a+0.5)/b)*b;\n\t\t\t\treturn floor(m+0.5);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tint len = int(sqrt(float(size)));\n\t\t\t\tfloat mean = 0.0;\n\t\t\t\tvec3 avgColor = vec3(0,0,0);\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tint x = int(intmod(float(i), float(len)));\n\t\t\t\t\tint y = i / len;\n\t\t\t\t\tvec2 dp = vec2(float(x)-(float(len)-1.0)/(2.0), float(y)-(float(len)-1.0)/(2.0));\n\t\t\t\t\tvec4 color = texture(tex, texCoord + dp / resolution);\n\t\t\t\t\tfloat gs = (color.r + color.g + color.b) / 3.0;\n\t\t\t\t\tmean += gs / float(size);\n\t\t\t\t\tavgColor += color.rgb / float(size);\n\t\t\t\t}\n\t\t\t\tfloat SSE = 0.0;\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tint x = int(intmod(float(i), float(len)));\n\t\t\t\t\tint y = i / len;\n\t\t\t\t\tvec2 dp = vec2(float(x)-(float(len)-1.0)/(2.0), float(y)-(float(len)-1.0)/(2.0));\n\t\t\t\t\tvec4 color = texture(tex, texCoord + dp / resolution);\n\t\t\t\t\tfloat gs = (color.r + color.g + color.b) / 3.0;\n\t\t\t\t\tSSE += (gs - mean) * (gs - mean);\n\t\t\t\t}\n\t\t\t\tfloat localVariance = SSE / (float(size) - 1.0);\n\t\t\t\tvec4 c = texture(tex, texCoord);\n\t\t\t\tfloat factor = min(1.0, max(0.0, (noiseVariance / localVariance)));\n\t\t\t\tvec3 result = c.rgb * (1.0 - factor) +  factor * (avgColor);\n\t\t\t\tfragColor = vec4(result, c.a);\n\t\t\t}\n\t\t", { width: width, noiseVariance: noiseVariance });
	},
	colorBalance: function colorBalance(_ref10) {
		var r = _ref10.r,
		    g = _ref10.g,
		    b = _ref10.b;

		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tuniform float r;\n\t\t\tuniform float g;\n\t\t\tuniform float b;\n\t\t\tvoid main() {\n\t\t\t\tvec4 c = texture(tex, texCoord);\n\t\t\t\tfragColor = vec4(c.r / r, c.g / g, c.b / b, c.a);\n\t\t\t}\n\t\t", { r: r, g: g, b: b });
	},
	dilate: function dilate(_ref11) {
		var element = _ref11.element;

		return new _effect2.default("\n\t\t\t#define size " + element.length + "\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tuniform float element[size];\n\t\t\tuniform vec2 resolution;\n\t\t\tfloat intmod(float a, float b) {\n\t\t\t\t\tfloat m=a-floor((a+0.5)/b)*b;\n\t\t\t\t\treturn floor(m+0.5);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tvec4 avg = vec4(0);\n\t\t\t\tint len = int(sqrt(float(size)));\n\t\t\t\tfloat total = 0.0;\n\t\t\t\tvec4 result = vec4(0);\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tif (element[i] < 0.5) continue;\n\t\t\t\t\tint x = int(intmod(float(i), float(len)));\n\t\t\t\t\tint y = i / len;\n\t\t\t\t\tvec2 dp = vec2(float(x)-(float(len)-1.0)/(2.0), float(y)-(float(len)-1.0)/(2.0));\n\t\t\t\t\tvec4 c = texture(tex, texCoord + dp / resolution);\n\t\t\t\t\tif (length(c.rgb) > length(result.rgb)) result = c;\n\t\t\t\t}\n\t\t\t\tfragColor = result;\n\t\t\t}\n\t\t", { element: element });
	},
	erode: function erode(_ref12) {
		var element = _ref12.element;

		return new _effect2.default("\n\t\t\t#define size " + element.length + "\n\t\t\tprecision highp float;\n\t\t\tin vec2 texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\tuniform sampler2D tex;\n\t\t\tuniform float element[size];\n\t\t\tuniform vec2 resolution;\n\t\t\tfloat intmod(float a, float b) {\n\t\t\t\t\tfloat m=a-floor((a+0.5)/b)*b;\n\t\t\t\t\treturn floor(m+0.5);\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tvec4 avg = vec4(0);\n\t\t\t\tint len = int(sqrt(float(size)));\n\t\t\t\tfloat total = 0.0;\n\t\t\t\tvec4 result = vec4(1);\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tif (element[i] < 0.5) continue;\n\t\t\t\t\tint x = int(intmod(float(i), float(len)));\n\t\t\t\t\tint y = i / len;\n\t\t\t\t\tvec2 dp = vec2(float(x)-(float(len)-1.0)/(2.0), float(y)-(float(len)-1.0)/(2.0));\n\t\t\t\t\tvec4 c = texture(tex, texCoord + dp / resolution);\n\t\t\t\t\tif (length(c.rgb) < length(result.rgb)) result = c;\n\t\t\t\t}\n\t\t\t\tfragColor = result;\n\t\t\t}\n\t\t", { element: element });
	},
	void: function _void() {
		return new _effect2.default("\n\t\t\tprecision highp float;\n\t\t\tout vec4 fragColor;\n\t\t\tvoid main() {\n\t\t\t\tfragColor = vec4(vec3(0), 1.0);\n\t\t\t}\n\t\t", {});
	}
};

},{"./effect.js":1}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _effect = require('./effect.js');

var _effect2 = _interopRequireDefault(_effect);

var _effects = require('./effects.js');

var _effects2 = _interopRequireDefault(_effects);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Trixie = function () {
	function Trixie(opts) {
		_classCallCheck(this, Trixie);

		this.initialized = false;
		this.uniformLocations = {};
		this.program = null;
		this.gl = null;
		this.frameBuffers = [];
		this.textures = [];
		this.originalTexture = null;
		this.effects = opts.effects;
		this.verticalFlip = _effects2.default.verticalFlip();
		this.identity = _effects2.default.identity();
		this.input = opts.input;
		this.output = opts.output;
		return this;
	}

	_createClass(Trixie, [{
		key: 'setupFrameBuffers',
		value: function setupFrameBuffers() {
			// Main texture / FBO
			var mTexture = this.gl.createTexture();
			this.gl.bindTexture(this.gl.TEXTURE_2D, mTexture);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
			this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.input.width, this.input.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
			var mFbo = this.gl.createFramebuffer();
			this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, mFbo);
			this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, mTexture, 0);
			this.textures.push(mTexture);
			this.frameBuffers.push(mFbo);
			// Swap texture / FBO
			var sTexture = this.gl.createTexture();
			this.gl.bindTexture(this.gl.TEXTURE_2D, sTexture);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
			this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.input.width, this.input.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
			var sFbo = this.gl.createFramebuffer();
			this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, sFbo);
			this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, sTexture, 0);
			this.textures.push(sTexture);
			this.frameBuffers.push(sFbo);
			// Original texture
			var oTexture = this.gl.createTexture();
			this.gl.bindTexture(this.gl.TEXTURE_2D, oTexture);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
			this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
			this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.input);
			this.originalTexture = oTexture;
		}
	}, {
		key: 'setupVertexBuffer',
		value: function setupVertexBuffer(program) {
			var x1 = 0;
			var y1 = 0;
			var x2 = this.input.width;
			var y2 = this.input.height;
			var verts = [x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2];
			var buffer = this.gl.createBuffer();
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
			this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(verts), this.gl.STATIC_DRAW);
			var position = this.gl.getAttribLocation(program, "position");
			this.gl.vertexAttribPointer(position, 2, this.gl.FLOAT, false, 0, 0);
			this.gl.enableVertexAttribArray(position);
			var texCoordData = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0];
			var tbuffer = this.gl.createBuffer();
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER, tbuffer);
			this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoordData), this.gl.STATIC_DRAW);
			var texCoord = this.gl.getAttribLocation(program, "coord");
			if (texCoord >= 0) {
				this.gl.vertexAttribPointer(texCoord, 2, this.gl.FLOAT, false, 0, 0);
				this.gl.enableVertexAttribArray(texCoord);
			}
		}
	}, {
		key: 'setFramebuffer',
		value: function setFramebuffer(fbo, width, height) {
			this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fbo);
			this.gl.viewport(0, 0, width, height);
		}
	}, {
		key: 'initialize',
		value: function initialize() {
			var _this = this;

			// GL Context
			var gl = this.output.getContext("webgl2");
			this.gl = gl;
			// Frame buffers
			this.setupFrameBuffers();
			// Shader programs
			this.effects.forEach(function (fx) {
				return fx.createShaderProgram(_this.gl);
			});
			this.verticalFlip.createShaderProgram(this.gl);
			this.identity.createShaderProgram(this.gl);
			this.initialized = true;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			if (!this.initialized) this.initialize();
			this.gl.bindTexture(this.gl.TEXTURE_2D, this.originalTexture);
			this.setupVertexBuffer(this.identity.shaderProgram); // it just works for any shader.
			var i = 0;

			var _loop = function _loop(k) {
				if (_this2.effects[k].enabled == false) return 'continue';
				_this2.gl.useProgram(_this2.effects[k].shaderProgram);
				_this2.setFramebuffer(_this2.frameBuffers[i % 2], _this2.input.width, _this2.input.height);
				// update uniforms
				_this2.gl.uniform1i(_this2.effects[k].uniformLocations.texture, 0);
				_this2.gl.uniform2f(_this2.effects[k].uniformLocations.resolution, _this2.output.width, _this2.output.height);
				if (_this2.effects[k].uniformsNeedUpdate) {
					Object.keys(_this2.effects[k].uniforms).forEach(function (name) {
						if (typeof _this2.effects[k].uniforms[name] === 'number') _this2.gl.uniform1f(_this2.effects[k].uniformLocations[name], _this2.effects[k].uniforms[name]);else if (_typeof(_this2.effects[k].uniforms[name]) === 'object') _this2.gl.uniform1fv(_this2.effects[k].uniformLocations[name], _this2.effects[k].uniforms[name]);else console.error('Error: unsupported uniform type (' + _typeof(_this2.effects[k].uniforms[name]) + ')');
					});
					_this2.effects[k].uniformsNeedUpdate = false;
				}
				// draw
				_this2.gl.drawArrays(_this2.gl.TRIANGLES, 0, 6);
				// use the texture we just rendered to.
				_this2.gl.bindTexture(_this2.gl.TEXTURE_2D, _this2.textures[i % 2]);
				i++;
			};

			for (var k = 0; k < this.effects.length; k++) {
				var _ret = _loop(k);

				if (_ret === 'continue') continue;
			}
			// draw to screen
			var finalEffect = void 0;
			finalEffect = this.verticalFlip;
			//if (i % 2 == 1)
			//else finalEffect = this.identity;
			this.gl.useProgram(finalEffect.shaderProgram);
			this.setFramebuffer(null, this.output.width, this.output.height);
			this.gl.uniform1i(finalEffect.uniformLocations.texture, 0);
			this.gl.uniform2f(finalEffect.uniformLocations.resolution, this.output.width, this.output.height);
			this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
			// this.output.width = this.output.scrollWidth; // ???
			// this.output.height = this.output.scrollHeight; // ???
			// gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			return this;
		}
	}]);

	return Trixie;
}();

exports.default = Trixie;


Trixie.effects = _effects2.default;
module.exports = Trixie;

},{"./effect.js":1,"./effects.js":2}]},{},[3])(3)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZWZmZWN0LmpzIiwic3JjL2VmZmVjdHMuanMiLCJzcmMvdHJpeGllLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztJQ0FxQixNO0FBQ3BCLGlCQUFZLFlBQVosRUFBMEIsUUFBMUIsRUFBb0M7QUFBQTs7QUFDbkMsT0FBSyxZQUFMLEdBQW9CLFlBQXBCO0FBQ0EsT0FBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsT0FBSyxnQkFBTCxHQUF3QixFQUF4QjtBQUNBLE9BQUssa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxPQUFLLGFBQUwsR0FBcUIsSUFBckI7QUFDQSxPQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0E7Ozs7c0NBQ21CLEUsRUFBSTtBQUFBOztBQUN2QixPQUFJLEtBQUssYUFBTCxLQUF1QixJQUEzQixFQUFpQztBQUNqQyxPQUFNLCtSQUFOO0FBV0EsT0FBTSxLQUFLLEdBQUcsWUFBSCxDQUFnQixHQUFHLGFBQW5CLENBQVg7QUFDQSxNQUFHLFlBQUgsQ0FBZ0IsRUFBaEIsRUFBb0Isc0JBQXNCLFlBQTFDO0FBQ0EsTUFBRyxhQUFILENBQWlCLEVBQWpCO0FBQ0EsT0FBTSxLQUFLLEdBQUcsWUFBSCxDQUFnQixHQUFHLGVBQW5CLENBQVg7QUFDQSxNQUFHLFlBQUgsQ0FBZ0IsRUFBaEIsRUFBb0Isc0JBQXNCLEtBQUssWUFBL0M7QUFDQSxNQUFHLGFBQUgsQ0FBaUIsRUFBakI7QUFDQSxPQUFJLFFBQVEsR0FBRyxnQkFBSCxDQUFvQixFQUFwQixDQUFaO0FBQ0EsT0FBSSxLQUFKLEVBQVcsUUFBUSxLQUFSLENBQWMsS0FBZDtBQUNYLFFBQUssYUFBTCxHQUFxQixHQUFHLGFBQUgsRUFBckI7QUFDQSxNQUFHLFlBQUgsQ0FBZ0IsS0FBSyxhQUFyQixFQUFvQyxFQUFwQztBQUNBLE1BQUcsWUFBSCxDQUFnQixLQUFLLGFBQXJCLEVBQW9DLEVBQXBD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U0FBM0IsRUFBc0MsQ0FBdEMsRUFBeUMsQ0FBekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFPLElBQVA7QUFDQTs7Ozs7O2tCQWpKbUIsTTs7O0FBb0pyQixPQUFPLE9BQVA7QUFDQSxPQUFPLE9BQVAsR0FBaUIsTUFBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWZmZWN0IHtcclxuXHRjb25zdHJ1Y3RvcihzaGFkZXJTdHJpbmcsIHVuaWZvcm1zKSB7XHJcblx0XHR0aGlzLnNoYWRlclN0cmluZyA9IHNoYWRlclN0cmluZztcclxuXHRcdHRoaXMudW5pZm9ybXMgPSB1bmlmb3JtcztcclxuXHRcdHRoaXMudW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xyXG5cdFx0dGhpcy51bmlmb3Jtc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5zaGFkZXJQcm9ncmFtID0gbnVsbDtcclxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblx0fVxyXG5cdGNyZWF0ZVNoYWRlclByb2dyYW0oZ2wpIHtcclxuXHRcdGlmICh0aGlzLnNoYWRlclByb2dyYW0gIT09IG51bGwpIHJldHVybjtcclxuXHRcdGNvbnN0IHZlcnRleFNoYWRlciA9IGBcclxuXHRcdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0XHRpbiB2ZWMyIHBvc2l0aW9uO1xyXG5cdFx0XHRpbiB2ZWMyIGNvb3JkO1xyXG5cdFx0XHRvdXQgdmVjMiB0ZXhDb29yZDtcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHR0ZXhDb29yZCA9IGNvb3JkO1xyXG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbi9yZXNvbHV0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XHJcblx0XHRcdH1cclxuXHRcdGA7XHJcblx0XHRjb25zdCB2cyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcclxuXHRcdGdsLnNoYWRlclNvdXJjZSh2cywgXCIjdmVyc2lvbiAzMDAgZXNcXG5cIiArIHZlcnRleFNoYWRlcik7XHJcblx0XHRnbC5jb21waWxlU2hhZGVyKHZzKTtcclxuXHRcdGNvbnN0IGZzID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XHJcblx0XHRnbC5zaGFkZXJTb3VyY2UoZnMsIFwiI3ZlcnNpb24gMzAwIGVzXFxuXCIgKyB0aGlzLnNoYWRlclN0cmluZyk7XHJcblx0XHRnbC5jb21waWxlU2hhZGVyKGZzKTtcclxuXHRcdGxldCBlcnJvciA9IGdsLmdldFNoYWRlckluZm9Mb2coZnMpO1xyXG5cdFx0aWYgKGVycm9yKSBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuXHRcdHRoaXMuc2hhZGVyUHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIHZzKTtcclxuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIGZzKTtcclxuXHRcdGdsLmxpbmtQcm9ncmFtKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XHJcblx0XHQvLyBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcblx0XHR0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudGltZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnNoYWRlclByb2dyYW0sIFwidGltZVwiKTtcclxuXHRcdHRoaXMudW5pZm9ybUxvY2F0aW9ucy5yZXNvbHV0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuc2hhZGVyUHJvZ3JhbSwgXCJyZXNvbHV0aW9uXCIpO1xyXG5cdFx0dGhpcy51bmlmb3JtTG9jYXRpb25zLnRleHR1cmUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5zaGFkZXJQcm9ncmFtLCBcInRleHR1cmVcIik7XHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLnVuaWZvcm1zKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG5cdFx0XHR0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbbmFtZV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5zaGFkZXJQcm9ncmFtLCBuYW1lKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRnZXRQYXJhbWV0ZXIoeCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudW5pZm9ybXNbeF1cclxuXHR9XHJcblx0c2V0UGFyYW1ldGVyKHgsIHZhbHVlKSB7XHJcblx0XHR0aGlzLnVuaWZvcm1zW3hdID0gdmFsdWU7XHJcblx0XHR0aGlzLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCBFZmZlY3QgZnJvbSAnLi9lZmZlY3QuanMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGlkZW50aXR5KCkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZmZlY3QoYFxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRcdGluIHZlYzIgdGV4Q29vcmQ7XHJcblx0XHRcdG91dCB2ZWM0IGZyYWdDb2xvcjtcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gdGV4dHVyZSh0ZXgsIHRleENvb3JkKTtcclxuXHRcdFx0fVxyXG5cdFx0YCwge30pO1xyXG5cdH0sXHJcblx0aW52ZXJ0KCkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZmZlY3QoYFxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRcdGluIHZlYzIgdGV4Q29vcmQ7XHJcblx0XHRcdG91dCB2ZWM0IGZyYWdDb2xvcjtcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUodGV4LCB0ZXhDb29yZCk7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gdmVjNCh2ZWMzKDEuMCAtIGNvbG9yLnJnYiksIGNvbG9yLmEpO1xyXG5cdFx0XHR9XHJcblx0XHRgLCB7fSk7XHJcblx0fSxcclxuXHRob3Jpem9udGFsRmxpcCgpIHtcclxuXHRcdHJldHVybiBuZXcgRWZmZWN0KGBcclxuXHRcdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0XHRpbiB2ZWMyIHRleENvb3JkO1xyXG5cdFx0XHRvdXQgdmVjNCBmcmFnQ29sb3I7XHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHRleDtcclxuXHRcdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHRcdHZlYzIgY29vcmQgPSB2ZWMyKDEuMC10ZXhDb29yZC54LCB0ZXhDb29yZC55KTtcclxuXHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZSh0ZXgsIGNvb3JkKTtcclxuXHRcdFx0XHRmcmFnQ29sb3IgPSBjb2xvcjtcclxuXHRcdFx0fVxyXG5cdFx0YCwge30pO1xyXG5cdH0sXHJcblx0dmVydGljYWxGbGlwKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZmZlY3QoYFxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRcdGluIHZlYzIgdGV4Q29vcmQ7XHJcblx0XHRcdG91dCB2ZWM0IGZyYWdDb2xvcjtcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0dmVjMiBjb29yZCA9IHZlYzIodGV4Q29vcmQueCwgMS4wIC0gdGV4Q29vcmQueSk7XHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUodGV4LCBjb29yZCk7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gY29sb3I7XHJcblx0XHRcdH1cclxuXHRcdGAsIHt9KTtcclxuXHR9LFxyXG5cdGthbGVpZG9zY29wZSh7cm90YXRpb24sIGJsYWRlcywgc2NhbGV9KSB7XHJcblx0XHRyZXR1cm4gbmV3IEVmZmVjdChgXHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdFx0aW4gdmVjMiB0ZXhDb29yZDtcclxuXHRcdFx0b3V0IHZlYzQgZnJhZ0NvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XHJcblx0XHRcdHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHNjYWxlO1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IGJsYWRlcztcclxuXHRcdFx0dmVjMiBLYWxlaWRvc2NvcGUoIHZlYzIgdXYsIGZsb2F0IG4pIHtcclxuXHRcdFx0XHRmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTtcclxuXHRcdFx0ICAgIGZsb2F0IGFuZ2xlID0gUEkgLyBuO1xyXG5cdFx0XHQgICAgZmxvYXQgciA9IGxlbmd0aCggdXYgKTtcclxuXHRcdFx0ICAgIGZsb2F0IGEgPSBhdGFuKCB1di55LCB1di54ICkgLyBhbmdsZTtcclxuXHRcdFx0ICAgIGEgPSBtaXgoIGZyYWN0KCBhICksIDEuMCAtIGZyYWN0KCBhICksIG1vZCggZmxvb3IoIGEgKSwgMi4wICkgKSAqIGFuZ2xlO1xyXG5cdFx0XHQgICAgLy8gcmFkaWFsID0gdmVjMihhLCByKTtcclxuXHRcdFx0ICAgIHJldHVybiB2ZWMyKCBjb3MoIGEgKSwgc2luKCBhICkgKSAqIHI7XHJcblx0XHQgICAgfVxyXG5cdFx0XHR2ZWMyIGN5Y2xlVXYodmVjMiB1dikge1xyXG5cdFx0XHRcdGZsb2F0IHg7XHJcblx0XHRcdFx0ZmxvYXQgeTtcclxuXHRcdFx0XHRpZiAodXYueCA+IDEuMCkgeCA9IDIuMCAtIHV2Lng7XHJcblx0XHRcdFx0ZWxzZSBpZiAodXYueCA8IC0xLjApIHggPSAtMi4wIC0gdXYueDtcclxuXHRcdFx0XHRlbHNlIHggPSB1di54O1xyXG5cdFx0XHRcdGlmICh1di55ID4gMS4wKSB5ID0gMi4wIC0gdXYueTtcclxuXHRcdFx0XHRlbHNlIGlmICh1di55IDwgLTEuMCkgeSA9IC0yLjAgLSB1di55O1xyXG5cdFx0XHRcdGVsc2UgeSA9IHV2Lnk7XHJcblx0XHRcdFx0cmV0dXJuIHZlYzIoeCwgeSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHRcdHZlYzIgcG9zID0gdmVjMigwLjUsIDAuNSk7XHJcblx0XHRcdFx0ZmxvYXQgYXNwZWN0ID0gcmVzb2x1dGlvbi55IC8gcmVzb2x1dGlvbi54O1xyXG5cdFx0XHRcdHZlYzIgdXYgPSAodGV4Q29vcmQueHkgLSAwLjUpICogIHZlYzIoMS4wL2FzcGVjdCwgMS4wKTtcclxuXHRcdFx0XHR2ZWMyIGsgPSBLYWxlaWRvc2NvcGUodXYgKiBtYXQyKGNvcyhyb3RhdGlvbiksIC1zaW4ocm90YXRpb24pLCBzaW4ocm90YXRpb24pLCBjb3Mocm90YXRpb24pKSwgYmxhZGVzKTtcclxuXHRcdFx0XHRtYXQyIHJtID0gbWF0Mihjb3Mocm90YXRpb24pLCAtc2luKHJvdGF0aW9uKSwgc2luKHJvdGF0aW9uKSwgY29zKHJvdGF0aW9uKSk7XHJcblx0XHRcdFx0dmVjMiBjb2xvdXJfayA9IHJtICogKGsgKiBzY2FsZSArIHBvcyk7XHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUodGV4LCBjeWNsZVV2KGNvbG91cl9rKSk7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gY29sb3I7XHJcblx0XHRcdH1cclxuXHRcdGAsIHtyb3RhdGlvbiwgYmxhZGVzLCBzY2FsZX0pO1xyXG5cdH0sXHJcblx0em9vbSh7eCwgeSwgZmFjdG9yfSkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZmZlY3QoYFxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgeDtcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCB5O1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IGZhY3RvcjtcclxuXHRcdFx0aW4gdmVjMiB0ZXhDb29yZDtcclxuXHRcdFx0b3V0IHZlYzQgZnJhZ0NvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHR2ZWMyIGNvb3JkID0gdmVjMigodGV4Q29vcmQueCAtIHgpL2ZhY3RvciArIHgsICh0ZXhDb29yZC55IC0geSkvZmFjdG9yICsgeSk7XHJcblx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUodGV4LCBjb29yZCk7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gY29sb3I7XHJcblx0XHRcdH1cclxuXHRcdGAsIHt4LCB5LCBmYWN0b3J9KTtcclxuXHR9LFxyXG5cdGNvbnZvbHZlKHtrZXJuZWx9KSB7XHJcblx0XHRyZXR1cm4gbmV3IEVmZmVjdChgXHJcblx0XHRcdCNkZWZpbmUgc2l6ZSAke2tlcm5lbC5sZW5ndGh9XHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdFx0aW4gdmVjMiB0ZXhDb29yZDtcclxuXHRcdFx0b3V0IHZlYzQgZnJhZ0NvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XHJcblx0XHRcdHVuaWZvcm0gZmxvYXQga2VybmVsW3NpemVdO1xyXG5cdFx0XHR1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcclxuXHRcdFx0ZmxvYXQgaW50bW9kKGZsb2F0IGEsIGZsb2F0IGIpIHtcclxuXHRcdFx0XHRcdGZsb2F0IG09YS1mbG9vcigoYSswLjUpL2IpKmI7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmxvb3IobSswLjUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHR2ZWM0IGF2ZyA9IHZlYzQoMCk7XHJcblx0XHRcdFx0aW50IGxlbiA9IGludChzcXJ0KGZsb2F0KHNpemUpKSk7XHJcblx0XHRcdFx0ZmxvYXQgdG90YWwgPSAwLjA7XHJcblx0XHRcdFx0Zm9yIChpbnQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuXHRcdFx0XHRcdGludCB4ID0gaW50KGludG1vZChmbG9hdChpKSwgZmxvYXQobGVuKSkpO1xyXG5cdFx0XHRcdFx0aW50IHkgPSBpIC8gbGVuO1xyXG5cdFx0XHRcdFx0ZmxvYXQgd2VpZ2h0ID0ga2VybmVsW2ldO1xyXG5cdFx0XHRcdFx0dmVjMiBkcCA9IHZlYzIoZmxvYXQoeCktKGZsb2F0KGxlbiktMS4wKS8oMi4wKSwgZmxvYXQoeSktKGZsb2F0KGxlbiktMS4wKS8oMi4wKSk7XHJcblx0XHRcdFx0XHRhdmcgKz0gd2VpZ2h0KnRleHR1cmUodGV4LCB0ZXhDb29yZCArIGRwIC8gcmVzb2x1dGlvbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZyYWdDb2xvciA9IHZlYzQoYXZnLnh5eiwgMS4wKTtcclxuXHRcdFx0fVxyXG5cdFx0YCwge2tlcm5lbH0pO1xyXG5cdH0sXHJcblx0dmVydGljYWxNaXJyb3IoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVmZmVjdChgXHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdFx0aW4gdmVjMiB0ZXhDb29yZDtcclxuXHRcdFx0b3V0IHZlYzQgZnJhZ0NvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHRmbG9hdCB4O1xyXG5cdFx0XHRcdGlmICh0ZXhDb29yZC54IDwgMC41KSB4ID0gdGV4Q29vcmQueDtcclxuXHRcdFx0XHRlbHNlIHggPSAxLjAgLSB0ZXhDb29yZC54O1xyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlKHRleCwgdmVjMih4LCB0ZXhDb29yZC55KSk7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gY29sb3I7XHJcblx0XHRcdH1cclxuXHRcdGAsIHt9KTtcclxuXHR9LFxyXG5cdGhvcml6b250YWxNaXJyb3IoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVmZmVjdChgXHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdFx0aW4gdmVjMiB0ZXhDb29yZDtcclxuXHRcdFx0b3V0IHZlYzQgZnJhZ0NvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHRmbG9hdCB5O1xyXG5cdFx0XHRcdGlmICh0ZXhDb29yZC55IDwgMC41KSB5ID0gdGV4Q29vcmQueTtcclxuXHRcdFx0XHRlbHNlIHkgPSAxLjAgLSB0ZXhDb29yZC55O1xyXG5cdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlKHRleCwgdmVjMih0ZXhDb29yZC54LCB5KSk7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gY29sb3I7XHJcblx0XHRcdH1cclxuXHRcdGAsIHt9KTtcclxuXHR9LFxyXG5cdGNvbG9yU2hpZnQoe3BoYXNlfSkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZmZlY3QoYFxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRcdGluIHZlYzIgdGV4Q29vcmQ7XHJcblx0XHRcdG91dCB2ZWM0IGZyYWdDb2xvcjtcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHBoYXNlO1xyXG5cdFx0XHR2ZWMzIHJnYjJoc3YodmVjMyBjKSB7XHJcblx0XHRcdCAgICB2ZWM0IEsgPSB2ZWM0KDAuMCwgLTEuMCAvIDMuMCwgMi4wIC8gMy4wLCAtMS4wKTtcclxuXHRcdFx0ICAgIHZlYzQgcCA9IG1peCh2ZWM0KGMuYmcsIEsud3opLCB2ZWM0KGMuZ2IsIEsueHkpLCBzdGVwKGMuYiwgYy5nKSk7XHJcblx0XHRcdCAgICB2ZWM0IHEgPSBtaXgodmVjNChwLnh5dywgYy5yKSwgdmVjNChjLnIsIHAueXp4KSwgc3RlcChwLngsIGMucikpO1xyXG5cdFx0XHQgICAgZmxvYXQgZCA9IHEueCAtIG1pbihxLncsIHEueSk7XHJcblx0XHRcdCAgICBmbG9hdCBlID0gMS4wZS0xMDtcclxuXHRcdFx0ICAgIHJldHVybiB2ZWMzKGFicyhxLnogKyAocS53IC0gcS55KSAvICg2LjAgKiBkICsgZSkpLCBkIC8gKHEueCArIGUpLCBxLngpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZlYzMgaHN2MnJnYih2ZWMzIGMpIHtcclxuXHRcdFx0ICAgIHZlYzQgSyA9IHZlYzQoMS4wLCAyLjAgLyAzLjAsIDEuMCAvIDMuMCwgMy4wKTtcclxuXHRcdFx0ICAgIHZlYzMgcCA9IGFicyhmcmFjdChjLnh4eCArIEsueHl6KSAqIDYuMCAtIEsud3d3KTtcclxuXHRcdFx0ICAgIHJldHVybiBjLnogKiBtaXgoSy54eHgsIGNsYW1wKHAgLSBLLnh4eCwgMC4wLCAxLjApLCBjLnkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHR2ZWM0IGNpbiA9IHRleHR1cmUodGV4LCB0ZXhDb29yZCk7XHJcblx0XHRcdFx0dmVjMyBoc3YgPSByZ2IyaHN2KGNpbi5yZ2IpO1xyXG5cdFx0XHRcdHZlYzMgY291dCA9IGhzdjJyZ2IodmVjMyhmcmFjdChoc3YueCArIHBoYXNlKSwgaHN2LnksIGhzdi56KSk7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gdmVjNChjb3V0LCAxLjApO1xyXG5cdFx0XHR9XHJcblx0XHRgLCB7cGhhc2V9KTtcclxuXHR9LFxyXG5cdGdhbW1hKHt2YWx1ZX0pIHtcclxuXHRcdHJldHVybiBuZXcgRWZmZWN0KGBcclxuXHRcdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHZhbHVlO1xyXG5cdFx0XHRpbiB2ZWMyIHRleENvb3JkO1xyXG5cdFx0XHRvdXQgdmVjNCBmcmFnQ29sb3I7XHJcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHRleDtcclxuXHRcdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHRcdHZlYzQgYyA9IHRleHR1cmUodGV4LCB0ZXhDb29yZCk7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gdmVjNChwb3coYy5yLCB2YWx1ZSksIHBvdyhjLmcsIHZhbHVlKSwgcG93KGMuYiwgdmFsdWUpLCBjLmEpO1xyXG5cdFx0XHR9XHJcblx0XHRgLCB7dmFsdWV9KTtcclxuXHR9LFxyXG5cdGxvY2FsSGlzdG9ncmFtRXF1YWxpemF0aW9uKHt3aWR0aCwgYmluc30pIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKFwiV2FybmluZzogTG9jYWwgaGlzdG9ncmFtIGVxdWFsaXphdGlvbiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZS5cIik7XHJcblx0XHRcdHJldHVybiBuZXcgRWZmZWN0KGBcclxuXHRcdFx0XHQjZGVmaW5lIHNpemUgJHtNYXRoLnJvdW5kKHdpZHRoKndpZHRoKX1cclxuXHRcdFx0XHQjZGVmaW5lIGJpbnMgJHtNYXRoLnJvdW5kKGJpbnMpfVxyXG5cdFx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdFx0XHR1bmlmb3JtIGZsb2F0IHZhbHVlO1xyXG5cdFx0XHRcdHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xyXG5cdFx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHRleDtcclxuXHRcdFx0XHRpbiB2ZWMyIHRleENvb3JkO1xyXG5cdFx0XHRcdG91dCB2ZWM0IGZyYWdDb2xvcjtcclxuXHRcdFx0XHRmbG9hdCBkaXN0cltiaW5zXTtcclxuXHRcdFx0XHRmbG9hdCBpbnRtb2QoZmxvYXQgYSwgZmxvYXQgYikge1xyXG5cdFx0XHRcdFx0ZmxvYXQgbT1hLWZsb29yKChhKzAuNSkvYikqYjtcclxuXHRcdFx0XHRcdHJldHVybiBmbG9vcihtKzAuNSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHRcdGludCBsZW4gPSBpbnQoc3FydChmbG9hdChzaXplKSkpO1xyXG5cdFx0XHRcdFx0ZmxvYXQgU1NFID0gMC4wO1xyXG5cdFx0XHRcdFx0ZmxvYXQgbWVhbiA9IDAuMDtcclxuXHRcdFx0XHRcdGZvciAoaW50IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGludCB4ID0gaW50KGludG1vZChmbG9hdChpKSwgZmxvYXQobGVuKSkpO1xyXG5cdFx0XHRcdFx0XHRpbnQgeSA9IGkgLyBsZW47XHJcblx0XHRcdFx0XHRcdHZlYzIgZHAgPSB2ZWMyKGZsb2F0KHgpLShmbG9hdChsZW4pLTEuMCkvKDIuMCksIGZsb2F0KHkpLShmbG9hdChsZW4pLTEuMCkvKDIuMCkpO1xyXG5cdFx0XHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZSh0ZXgsIHRleENvb3JkICsgZHAgLyByZXNvbHV0aW9uKTtcclxuXHRcdFx0XHRcdFx0ZmxvYXQgZ3MgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDtcclxuXHRcdFx0XHRcdFx0aW50IGhpID0gaW50KG1pbihmbG9hdChiaW5zKS0xLjAsIGZsb29yKGdzICogZmxvYXQoYmlucykpKSk7XHJcblx0XHRcdFx0XHRcdGRpc3RyW2hpXSArPSAxLjAvZmxvYXQoc2l6ZSk7XHJcblx0XHRcdFx0XHRcdG1lYW4gKz0gZ3MgLyBmbG9hdChzaXplKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZvciAoaW50IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGludCB4ID0gaW50KGludG1vZChmbG9hdChpKSwgZmxvYXQobGVuKSkpO1xyXG5cdFx0XHRcdFx0XHRpbnQgeSA9IGkgLyBsZW47XHJcblx0XHRcdFx0XHRcdHZlYzIgZHAgPSB2ZWMyKGZsb2F0KHgpLShmbG9hdChsZW4pLTEuMCkvKDIuMCksIGZsb2F0KHkpLShmbG9hdChsZW4pLTEuMCkvKDIuMCkpO1xyXG5cdFx0XHRcdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZSh0ZXgsIHRleENvb3JkICsgZHAgLyByZXNvbHV0aW9uKTtcclxuXHRcdFx0XHRcdFx0ZmxvYXQgZ3MgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDtcclxuXHRcdFx0XHRcdFx0U1NFICs9IChncyAtIG1lYW4pICogKGdzIC0gbWVhbik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2ZWM0IGMgPSB0ZXh0dXJlKHRleCwgdGV4Q29vcmQpO1xyXG5cdFx0XHRcdFx0ZmxvYXQgZ3MgPSAoYy5yICsgYy5nICsgYy5iKSAvIDMuMDtcclxuXHRcdFx0XHRcdGludCBiaW4gPSAgaW50KG1pbihmbG9hdChiaW5zKS0xLjAsIGZsb29yKGdzICogZmxvYXQoYmlucykpKSk7XHJcblx0XHRcdFx0XHRmbG9hdCBmZ3MgPSAwLjA7XHJcblx0XHRcdFx0XHRmb3IgKGludCBrID0gMDsgayA8PSBiaW47IGsrKykgZmdzICs9IGRpc3RyW2tdO1xyXG5cdFx0XHRcdFx0Ly8gYWRhcHRhdGlvblxyXG5cdFx0XHRcdFx0ZmxvYXQgdmFyX21heCA9IChmbG9hdChzaXplKSAvIChmbG9hdChzaXplKSAtIDEuMCkpIC8gMTYuMDtcclxuXHRcdFx0XHRcdGZsb2F0IHZhciA9IFNTRSAvIChmbG9hdChzaXplKSAtIDEuMCk7XHJcblx0XHRcdFx0XHRmbG9hdCBhZGFwdGF0aW9uID0gdmFyIC8gKHZhcl9tYXgpO1xyXG5cdFx0XHRcdFx0dmVjMyByZXN1bHQgPSBhZGFwdGF0aW9uICogKGZncyAvIGdzKSAqIGMucmdiICsgKDEuMCAtIGFkYXB0YXRpb24pICogYy5yZ2I7XHJcblx0XHRcdFx0XHRmcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdCwgYy5hKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdGAsIHt3aWR0aCwgYmluc30pO1xyXG5cdH0sXHJcblx0d2hpdGVOb2lzZSh7aW50ZW5zaXR5fSkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZmZlY3QoYFxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRcdGluIHZlYzIgdGV4Q29vcmQ7XHJcblx0XHRcdG91dCB2ZWM0IGZyYWdDb2xvcjtcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IGludGVuc2l0eTtcclxuXHRcdFx0ZmxvYXQgcmFuZCh2ZWMyIGNvKSB7XHJcblx0XHRcdFx0Ly8gU291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MjAwMjI0L3JhbmRvbS1ub2lzZS1mdW5jdGlvbnMtZm9yLWdsc2xcclxuXHRcdFx0ICAgIGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4O1xyXG5cdFx0XHQgICAgaGlnaHAgZmxvYXQgYiA9IDc4LjIzMztcclxuXHRcdFx0ICAgIGhpZ2hwIGZsb2F0IGMgPSA0Mzc1OC41NDUzO1xyXG5cdFx0XHQgICAgaGlnaHAgZmxvYXQgZHQ9IGRvdChjby54eSAsdmVjMihhLGIpKTtcclxuXHRcdFx0ICAgIGhpZ2hwIGZsb2F0IHNuPSBtb2QoZHQsMy4xNCk7XHJcblx0XHRcdCAgICByZXR1cm4gZnJhY3Qoc2luKHNuKSAqIGMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHRmbG9hdCBybmQgPSByYW5kKHRleENvb3JkKTtcclxuXHRcdFx0XHR2ZWM0IGMgPSB0ZXh0dXJlKHRleCwgdGV4Q29vcmQpO1xyXG5cdFx0XHRcdGZyYWdDb2xvciA9IHZlYzQoaW50ZW5zaXR5ICogdmVjMygyLjAqcm5kIC0gMS4wKSArICgxLjAgLSBpbnRlbnNpdHkpICogYy5yZ2IsIDEuMCk7XHJcblx0XHRcdH1cclxuXHRcdGAsIHtpbnRlbnNpdHl9KTtcclxuXHR9LFxyXG5cdHNhbHRBbmRQZXBwZXJOb2lzZSh7cHJvYmFiaWxpdHl9KSB7XHJcblx0XHRyZXR1cm4gbmV3IEVmZmVjdChgXHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdFx0aW4gdmVjMiB0ZXhDb29yZDtcclxuXHRcdFx0b3V0IHZlYzQgZnJhZ0NvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IHByb2JhYmlsaXR5O1xyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XHJcblx0XHRcdGZsb2F0IHJhbmQodmVjMiBjbykge1xyXG5cdFx0XHRcdC8vIFNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDIwMDIyNC9yYW5kb20tbm9pc2UtZnVuY3Rpb25zLWZvci1nbHNsXHJcblx0XHRcdCAgICBoaWdocCBmbG9hdCBhID0gMTIuOTg5ODtcclxuXHRcdFx0ICAgIGhpZ2hwIGZsb2F0IGIgPSA3OC4yMzM7XHJcblx0XHRcdCAgICBoaWdocCBmbG9hdCBjID0gNDM3NTguNTQ1MztcclxuXHRcdFx0ICAgIGhpZ2hwIGZsb2F0IGR0PSBkb3QoY28ueHkgLHZlYzIoYSxiKSk7XHJcblx0XHRcdCAgICBoaWdocCBmbG9hdCBzbj0gbW9kKGR0LDMuMTQpO1xyXG5cdFx0XHQgICAgcmV0dXJuIGZyYWN0KHNpbihzbikgKiBjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0ZmxvYXQgcm5kMSA9IHJhbmQodGV4Q29vcmQpO1xyXG5cdFx0XHRcdGZsb2F0IHJuZDIgPSByYW5kKHZlYzIoMS4wLCAxLjApIC0gdGV4Q29vcmQpO1xyXG5cdFx0XHRcdHZlYzQgYyA9IHRleHR1cmUodGV4LCB0ZXhDb29yZCk7XHJcblx0XHRcdFx0dmVjMyByZXN1bHQgPSBzdGVwKHByb2JhYmlsaXR5LCBybmQxKSAqIGMucmdiICsgKDEuMCAtIHN0ZXAocHJvYmFiaWxpdHksIHJuZDEpKSAqIChzdGVwKDAuNSwgcm5kMikgKiB2ZWMzKDEsIDEsIDEpKTtcclxuXHRcdFx0XHRmcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdCwgYy5hKTtcclxuXHRcdFx0fVxyXG5cdFx0YCwge3Byb2JhYmlsaXR5fSk7XHJcblx0fSxcclxuXHRhZGFwdGl2ZU1lYW5GaWx0ZXIoe3dpZHRoLCBub2lzZVZhcmlhbmNlfSkge1xyXG5cdFx0cmV0dXJuIG5ldyBFZmZlY3QoYFxyXG5cdFx0XHQjZGVmaW5lIHNpemUgJHtNYXRoLnJvdW5kKHdpZHRoKndpZHRoKX1cclxuXHRcdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0XHRpbiB2ZWMyIHRleENvb3JkO1xyXG5cdFx0XHRvdXQgdmVjNCBmcmFnQ29sb3I7XHJcblx0XHRcdHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgbm9pc2VWYXJpYW5jZTtcclxuXHRcdFx0ZmxvYXQgaW50bW9kKGZsb2F0IGEsIGZsb2F0IGIpIHtcclxuXHRcdFx0XHRmbG9hdCBtPWEtZmxvb3IoKGErMC41KS9iKSpiO1xyXG5cdFx0XHRcdHJldHVybiBmbG9vcihtKzAuNSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHRcdGludCBsZW4gPSBpbnQoc3FydChmbG9hdChzaXplKSkpO1xyXG5cdFx0XHRcdGZsb2F0IG1lYW4gPSAwLjA7XHJcblx0XHRcdFx0dmVjMyBhdmdDb2xvciA9IHZlYzMoMCwwLDApO1xyXG5cdFx0XHRcdGZvciAoaW50IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcblx0XHRcdFx0XHRpbnQgeCA9IGludChpbnRtb2QoZmxvYXQoaSksIGZsb2F0KGxlbikpKTtcclxuXHRcdFx0XHRcdGludCB5ID0gaSAvIGxlbjtcclxuXHRcdFx0XHRcdHZlYzIgZHAgPSB2ZWMyKGZsb2F0KHgpLShmbG9hdChsZW4pLTEuMCkvKDIuMCksIGZsb2F0KHkpLShmbG9hdChsZW4pLTEuMCkvKDIuMCkpO1xyXG5cdFx0XHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUodGV4LCB0ZXhDb29yZCArIGRwIC8gcmVzb2x1dGlvbik7XHJcblx0XHRcdFx0XHRmbG9hdCBncyA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xyXG5cdFx0XHRcdFx0bWVhbiArPSBncyAvIGZsb2F0KHNpemUpO1xyXG5cdFx0XHRcdFx0YXZnQ29sb3IgKz0gY29sb3IucmdiIC8gZmxvYXQoc2l6ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZsb2F0IFNTRSA9IDAuMDtcclxuXHRcdFx0XHRmb3IgKGludCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG5cdFx0XHRcdFx0aW50IHggPSBpbnQoaW50bW9kKGZsb2F0KGkpLCBmbG9hdChsZW4pKSk7XHJcblx0XHRcdFx0XHRpbnQgeSA9IGkgLyBsZW47XHJcblx0XHRcdFx0XHR2ZWMyIGRwID0gdmVjMihmbG9hdCh4KS0oZmxvYXQobGVuKS0xLjApLygyLjApLCBmbG9hdCh5KS0oZmxvYXQobGVuKS0xLjApLygyLjApKTtcclxuXHRcdFx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlKHRleCwgdGV4Q29vcmQgKyBkcCAvIHJlc29sdXRpb24pO1xyXG5cdFx0XHRcdFx0ZmxvYXQgZ3MgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDtcclxuXHRcdFx0XHRcdFNTRSArPSAoZ3MgLSBtZWFuKSAqIChncyAtIG1lYW4pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmbG9hdCBsb2NhbFZhcmlhbmNlID0gU1NFIC8gKGZsb2F0KHNpemUpIC0gMS4wKTtcclxuXHRcdFx0XHR2ZWM0IGMgPSB0ZXh0dXJlKHRleCwgdGV4Q29vcmQpO1xyXG5cdFx0XHRcdGZsb2F0IGZhY3RvciA9IG1pbigxLjAsIG1heCgwLjAsIChub2lzZVZhcmlhbmNlIC8gbG9jYWxWYXJpYW5jZSkpKTtcclxuXHRcdFx0XHR2ZWMzIHJlc3VsdCA9IGMucmdiICogKDEuMCAtIGZhY3RvcikgKyAgZmFjdG9yICogKGF2Z0NvbG9yKTtcclxuXHRcdFx0XHRmcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdCwgYy5hKTtcclxuXHRcdFx0fVxyXG5cdFx0YCwge3dpZHRoLCBub2lzZVZhcmlhbmNlfSk7XHJcblx0fSxcclxuXHRjb2xvckJhbGFuY2Uoe3IsIGcsIGJ9KSB7XHJcblx0XHRyZXR1cm4gbmV3IEVmZmVjdChgXHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdFx0aW4gdmVjMiB0ZXhDb29yZDtcclxuXHRcdFx0b3V0IHZlYzQgZnJhZ0NvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgcjtcclxuXHRcdFx0dW5pZm9ybSBmbG9hdCBnO1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IGI7XHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHR2ZWM0IGMgPSB0ZXh0dXJlKHRleCwgdGV4Q29vcmQpO1xyXG5cdFx0XHRcdGZyYWdDb2xvciA9IHZlYzQoYy5yIC8gciwgYy5nIC8gZywgYy5iIC8gYiwgYy5hKTtcclxuXHRcdFx0fVxyXG5cdFx0YCwge3IsIGcsIGJ9KTtcclxuXHR9LFxyXG5cdGRpbGF0ZSh7ZWxlbWVudH0pIHtcclxuXHRcdHJldHVybiBuZXcgRWZmZWN0KGBcclxuXHRcdFx0I2RlZmluZSBzaXplICR7ZWxlbWVudC5sZW5ndGh9XHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdFx0aW4gdmVjMiB0ZXhDb29yZDtcclxuXHRcdFx0b3V0IHZlYzQgZnJhZ0NvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgZWxlbWVudFtzaXplXTtcclxuXHRcdFx0dW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XHJcblx0XHRcdGZsb2F0IGludG1vZChmbG9hdCBhLCBmbG9hdCBiKSB7XHJcblx0XHRcdFx0XHRmbG9hdCBtPWEtZmxvb3IoKGErMC41KS9iKSpiO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZsb29yKG0rMC41KTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0dmVjNCBhdmcgPSB2ZWM0KDApO1xyXG5cdFx0XHRcdGludCBsZW4gPSBpbnQoc3FydChmbG9hdChzaXplKSkpO1xyXG5cdFx0XHRcdGZsb2F0IHRvdGFsID0gMC4wO1xyXG5cdFx0XHRcdHZlYzQgcmVzdWx0ID0gdmVjNCgwKTtcclxuXHRcdFx0XHRmb3IgKGludCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnRbaV0gPCAwLjUpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0aW50IHggPSBpbnQoaW50bW9kKGZsb2F0KGkpLCBmbG9hdChsZW4pKSk7XHJcblx0XHRcdFx0XHRpbnQgeSA9IGkgLyBsZW47XHJcblx0XHRcdFx0XHR2ZWMyIGRwID0gdmVjMihmbG9hdCh4KS0oZmxvYXQobGVuKS0xLjApLygyLjApLCBmbG9hdCh5KS0oZmxvYXQobGVuKS0xLjApLygyLjApKTtcclxuXHRcdFx0XHRcdHZlYzQgYyA9IHRleHR1cmUodGV4LCB0ZXhDb29yZCArIGRwIC8gcmVzb2x1dGlvbik7XHJcblx0XHRcdFx0XHRpZiAobGVuZ3RoKGMucmdiKSA+IGxlbmd0aChyZXN1bHQucmdiKSkgcmVzdWx0ID0gYztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gcmVzdWx0O1xyXG5cdFx0XHR9XHJcblx0XHRgLCB7ZWxlbWVudH0pO1xyXG5cdH0sXHJcblx0ZXJvZGUoe2VsZW1lbnR9KSB7XHJcblx0XHRyZXR1cm4gbmV3IEVmZmVjdChgXHJcblx0XHRcdCNkZWZpbmUgc2l6ZSAke2VsZW1lbnQubGVuZ3RofVxyXG5cdFx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRcdGluIHZlYzIgdGV4Q29vcmQ7XHJcblx0XHRcdG91dCB2ZWM0IGZyYWdDb2xvcjtcclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IGVsZW1lbnRbc2l6ZV07XHJcblx0XHRcdHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xyXG5cdFx0XHRmbG9hdCBpbnRtb2QoZmxvYXQgYSwgZmxvYXQgYikge1xyXG5cdFx0XHRcdFx0ZmxvYXQgbT1hLWZsb29yKChhKzAuNSkvYikqYjtcclxuXHRcdFx0XHRcdHJldHVybiBmbG9vcihtKzAuNSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHRcdHZlYzQgYXZnID0gdmVjNCgwKTtcclxuXHRcdFx0XHRpbnQgbGVuID0gaW50KHNxcnQoZmxvYXQoc2l6ZSkpKTtcclxuXHRcdFx0XHRmbG9hdCB0b3RhbCA9IDAuMDtcclxuXHRcdFx0XHR2ZWM0IHJlc3VsdCA9IHZlYzQoMSk7XHJcblx0XHRcdFx0Zm9yIChpbnQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChlbGVtZW50W2ldIDwgMC41KSBjb250aW51ZTtcclxuXHRcdFx0XHRcdGludCB4ID0gaW50KGludG1vZChmbG9hdChpKSwgZmxvYXQobGVuKSkpO1xyXG5cdFx0XHRcdFx0aW50IHkgPSBpIC8gbGVuO1xyXG5cdFx0XHRcdFx0dmVjMiBkcCA9IHZlYzIoZmxvYXQoeCktKGZsb2F0KGxlbiktMS4wKS8oMi4wKSwgZmxvYXQoeSktKGZsb2F0KGxlbiktMS4wKS8oMi4wKSk7XHJcblx0XHRcdFx0XHR2ZWM0IGMgPSB0ZXh0dXJlKHRleCwgdGV4Q29vcmQgKyBkcCAvIHJlc29sdXRpb24pO1xyXG5cdFx0XHRcdFx0aWYgKGxlbmd0aChjLnJnYikgPCBsZW5ndGgocmVzdWx0LnJnYikpIHJlc3VsdCA9IGM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZyYWdDb2xvciA9IHJlc3VsdDtcclxuXHRcdFx0fVxyXG5cdFx0YCwge2VsZW1lbnR9KTtcclxuXHR9LFxyXG5cdHZvaWQoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEVmZmVjdChgXHJcblx0XHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdFx0b3V0IHZlYzQgZnJhZ0NvbG9yO1xyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0ZnJhZ0NvbG9yID0gdmVjNCh2ZWMzKDApLCAxLjApO1xyXG5cdFx0XHR9XHJcblx0XHRgLCB7fSk7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCBFZmZlY3QgZnJvbSAnLi9lZmZlY3QuanMnO1xyXG5pbXBvcnQgRWZmZWN0cyBmcm9tICcuL2VmZmVjdHMuanMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJpeGllIHtcclxuXHRjb25zdHJ1Y3RvcihvcHRzKSB7XHJcblx0XHR0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcblx0XHR0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcclxuXHRcdHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcblx0XHR0aGlzLmdsID0gbnVsbDtcclxuXHRcdHRoaXMuZnJhbWVCdWZmZXJzID0gW107XHJcblx0XHR0aGlzLnRleHR1cmVzID0gW107XHJcblx0XHR0aGlzLm9yaWdpbmFsVGV4dHVyZSA9IG51bGw7XHJcblx0XHR0aGlzLmVmZmVjdHMgPSBvcHRzLmVmZmVjdHM7XHJcblx0XHR0aGlzLnZlcnRpY2FsRmxpcCA9IEVmZmVjdHMudmVydGljYWxGbGlwKCk7XHJcblx0XHR0aGlzLmlkZW50aXR5ID0gRWZmZWN0cy5pZGVudGl0eSgpO1xyXG5cdFx0dGhpcy5pbnB1dCA9IG9wdHMuaW5wdXQ7XHJcblx0XHR0aGlzLm91dHB1dCA9IG9wdHMub3V0cHV0O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cdHNldHVwRnJhbWVCdWZmZXJzKCkge1xyXG5cdFx0Ly8gTWFpbiB0ZXh0dXJlIC8gRkJPXHJcblx0XHRjb25zdCBtVGV4dHVyZSA9IHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cdFx0dGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIG1UZXh0dXJlKTtcclxuXHRcdHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XHJcblx0XHR0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xyXG5cdFx0dGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuZ2wuTkVBUkVTVCk7XHJcblx0XHR0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5nbC5ORUFSRVNUKTtcclxuXHRcdHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5pbnB1dC53aWR0aCwgdGhpcy5pbnB1dC5oZWlnaHQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcclxuXHRcdGNvbnN0IG1GYm8gPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcblx0XHR0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBtRmJvKTtcclxuXHRcdHRoaXMuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5nbC5URVhUVVJFXzJELCBtVGV4dHVyZSwgMCk7XHJcblx0XHR0aGlzLnRleHR1cmVzLnB1c2gobVRleHR1cmUpO1xyXG5cdFx0dGhpcy5mcmFtZUJ1ZmZlcnMucHVzaChtRmJvKTtcclxuXHRcdC8vIFN3YXAgdGV4dHVyZSAvIEZCT1xyXG5cdFx0Y29uc3Qgc1RleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHRcdHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBzVGV4dHVyZSk7XHJcblx0XHR0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xyXG5cdFx0dGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcclxuXHRcdHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLk5FQVJFU1QpO1xyXG5cdFx0dGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuZ2wuTkVBUkVTVCk7XHJcblx0XHR0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuaW5wdXQud2lkdGgsIHRoaXMuaW5wdXQuaGVpZ2h0LCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XHJcblx0XHRjb25zdCBzRmJvID0gdGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG5cdFx0dGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgc0Zibyk7XHJcblx0XHR0aGlzLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRoaXMuZ2wuVEVYVFVSRV8yRCwgc1RleHR1cmUsIDApO1xyXG5cdFx0dGhpcy50ZXh0dXJlcy5wdXNoKHNUZXh0dXJlKTtcclxuXHRcdHRoaXMuZnJhbWVCdWZmZXJzLnB1c2goc0Zibyk7XHJcblx0XHQvLyBPcmlnaW5hbCB0ZXh0dXJlXHJcblx0XHRjb25zdCBvVGV4dHVyZSA9IHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cdFx0dGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIG9UZXh0dXJlKTtcclxuXHRcdHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XHJcblx0XHR0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xyXG5cdFx0dGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuZ2wuTkVBUkVTVCk7XHJcblx0XHR0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5nbC5ORUFSRVNUKTtcclxuXHRcdHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuaW5wdXQpO1xyXG5cdFx0dGhpcy5vcmlnaW5hbFRleHR1cmUgPSBvVGV4dHVyZTtcclxuXHR9XHJcblx0c2V0dXBWZXJ0ZXhCdWZmZXIocHJvZ3JhbSkge1xyXG5cdFx0Y29uc3QgeDEgPSAwO1xyXG5cdFx0Y29uc3QgeTEgPSAwO1xyXG5cdFx0Y29uc3QgeDIgPSB0aGlzLmlucHV0LndpZHRoO1xyXG5cdFx0Y29uc3QgeTIgPSB0aGlzLmlucHV0LmhlaWdodDtcclxuXHRcdGNvbnN0IHZlcnRzID0gW1xyXG5cdFx0XHR4MSwgeTEsXHJcblx0XHRcdHgyLCB5MSxcclxuXHRcdFx0eDEsIHkyLFxyXG5cdFx0XHR4MSwgeTIsXHJcblx0XHRcdHgyLCB5MSxcclxuXHRcdFx0eDIsIHkyXHJcblx0XHRdO1xyXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuXHRcdHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh2ZXJ0cyksIHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwicG9zaXRpb25cIik7XHJcblx0XHR0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb24sIDIsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuXHRcdHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb24pO1xyXG5cdFx0Y29uc3QgdGV4Q29vcmREYXRhID0gW1xyXG4gICAgIFx0XHQwLjAsICAwLjAsXHJcblx0XHRcdDEuMCwgIDAuMCxcclxuXHRcdFx0MC4wLCAgMS4wLFxyXG5cdFx0XHQwLjAsICAxLjAsXHJcblx0XHRcdDEuMCwgIDAuMCxcclxuXHRcdFx0MS4wLCAgMS4wXHJcblx0XHRdO1xyXG5cdFx0Y29uc3QgdGJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHR0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRidWZmZXIpO1xyXG5cdFx0dGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRleENvb3JkRGF0YSksIHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xyXG5cdFx0Y29uc3QgdGV4Q29vcmQgPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiY29vcmRcIik7XHJcblx0XHRpZiAodGV4Q29vcmQgPj0gMCkge1xyXG5cdFx0XHR0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4Q29vcmQsIDIsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuXHRcdFx0dGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0ZXhDb29yZCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHNldEZyYW1lYnVmZmVyKGZibywgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0dGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgZmJvKTtcclxuXHRcdHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblx0fVxyXG5cdGluaXRpYWxpemUoKSB7XHJcblx0XHQvLyBHTCBDb250ZXh0XHJcblx0XHRjb25zdCBnbCA9IHRoaXMub3V0cHV0LmdldENvbnRleHQoXCJ3ZWJnbDJcIik7XHJcblx0XHR0aGlzLmdsID0gZ2w7XHJcblx0XHQvLyBGcmFtZSBidWZmZXJzXHJcblx0XHR0aGlzLnNldHVwRnJhbWVCdWZmZXJzKCk7XHJcblx0XHQvLyBTaGFkZXIgcHJvZ3JhbXNcclxuXHRcdHRoaXMuZWZmZWN0cy5mb3JFYWNoKGZ4ID0+IGZ4LmNyZWF0ZVNoYWRlclByb2dyYW0odGhpcy5nbCkpO1xyXG5cdFx0dGhpcy52ZXJ0aWNhbEZsaXAuY3JlYXRlU2hhZGVyUHJvZ3JhbSh0aGlzLmdsKTtcclxuXHRcdHRoaXMuaWRlbnRpdHkuY3JlYXRlU2hhZGVyUHJvZ3JhbSh0aGlzLmdsKTtcclxuXHRcdHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cdH1cclxuXHRyZW5kZXIoKSB7XHJcblx0XHRpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cdFx0dGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMub3JpZ2luYWxUZXh0dXJlKTtcclxuXHRcdHRoaXMuc2V0dXBWZXJ0ZXhCdWZmZXIodGhpcy5pZGVudGl0eS5zaGFkZXJQcm9ncmFtKTsgLy8gaXQganVzdCB3b3JrcyBmb3IgYW55IHNoYWRlci5cclxuXHRcdGxldCBpID0gMDtcclxuXHRcdGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5lZmZlY3RzLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdGlmICh0aGlzLmVmZmVjdHNba10uZW5hYmxlZCA9PSBmYWxzZSkgY29udGludWU7XHJcblx0XHRcdHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLmVmZmVjdHNba10uc2hhZGVyUHJvZ3JhbSk7XHJcblx0XHRcdHRoaXMuc2V0RnJhbWVidWZmZXIodGhpcy5mcmFtZUJ1ZmZlcnNbaSAlIDJdLCB0aGlzLmlucHV0LndpZHRoLCB0aGlzLmlucHV0LmhlaWdodCk7XHJcblx0XHRcdC8vIHVwZGF0ZSB1bmlmb3Jtc1xyXG5cdFx0XHR0aGlzLmdsLnVuaWZvcm0xaSh0aGlzLmVmZmVjdHNba10udW5pZm9ybUxvY2F0aW9ucy50ZXh0dXJlLCAwKTtcclxuXHRcdFx0dGhpcy5nbC51bmlmb3JtMmYodGhpcy5lZmZlY3RzW2tdLnVuaWZvcm1Mb2NhdGlvbnMucmVzb2x1dGlvbiwgdGhpcy5vdXRwdXQud2lkdGgsIHRoaXMub3V0cHV0LmhlaWdodCk7XHJcblx0XHRcdGlmICh0aGlzLmVmZmVjdHNba10udW5pZm9ybXNOZWVkVXBkYXRlKSB7XHJcblx0XHRcdFx0T2JqZWN0LmtleXModGhpcy5lZmZlY3RzW2tdLnVuaWZvcm1zKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLmVmZmVjdHNba10udW5pZm9ybXNbbmFtZV0gPT09ICdudW1iZXInKSB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLmVmZmVjdHNba10udW5pZm9ybUxvY2F0aW9uc1tuYW1lXSwgdGhpcy5lZmZlY3RzW2tdLnVuaWZvcm1zW25hbWVdKTtcclxuXHRcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiB0aGlzLmVmZmVjdHNba10udW5pZm9ybXNbbmFtZV0gPT09ICdvYmplY3QnKSB0aGlzLmdsLnVuaWZvcm0xZnYodGhpcy5lZmZlY3RzW2tdLnVuaWZvcm1Mb2NhdGlvbnNbbmFtZV0sIHRoaXMuZWZmZWN0c1trXS51bmlmb3Jtc1tuYW1lXSk7XHJcblx0XHRcdFx0XHRlbHNlIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOiB1bnN1cHBvcnRlZCB1bmlmb3JtIHR5cGUgKCcgKyB0eXBlb2YgdGhpcy5lZmZlY3RzW2tdLnVuaWZvcm1zW25hbWVdICsgJyknKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHR0aGlzLmVmZmVjdHNba10udW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gZHJhd1xyXG5cdFx0XHR0aGlzLmdsLmRyYXdBcnJheXModGhpcy5nbC5UUklBTkdMRVMsIDAsIDYpO1xyXG5cdFx0XHQvLyB1c2UgdGhlIHRleHR1cmUgd2UganVzdCByZW5kZXJlZCB0by5cclxuXHRcdFx0dGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZXNbaSAlIDJdKTtcclxuXHRcdFx0aSsrO1xyXG5cdFx0fVxyXG5cdFx0Ly8gZHJhdyB0byBzY3JlZW5cclxuXHRcdGxldCBmaW5hbEVmZmVjdDtcclxuXHRcdGZpbmFsRWZmZWN0ID0gdGhpcy52ZXJ0aWNhbEZsaXA7XHJcblx0XHQvL2lmIChpICUgMiA9PSAxKVxyXG5cdFx0Ly9lbHNlIGZpbmFsRWZmZWN0ID0gdGhpcy5pZGVudGl0eTtcclxuXHRcdHRoaXMuZ2wudXNlUHJvZ3JhbShmaW5hbEVmZmVjdC5zaGFkZXJQcm9ncmFtKTtcclxuXHRcdHRoaXMuc2V0RnJhbWVidWZmZXIobnVsbCwgdGhpcy5vdXRwdXQud2lkdGgsIHRoaXMub3V0cHV0LmhlaWdodCk7XHJcblx0XHR0aGlzLmdsLnVuaWZvcm0xaShmaW5hbEVmZmVjdC51bmlmb3JtTG9jYXRpb25zLnRleHR1cmUsIDApO1xyXG5cdFx0dGhpcy5nbC51bmlmb3JtMmYoZmluYWxFZmZlY3QudW5pZm9ybUxvY2F0aW9ucy5yZXNvbHV0aW9uLCB0aGlzLm91dHB1dC53aWR0aCwgdGhpcy5vdXRwdXQuaGVpZ2h0KTtcclxuXHRcdHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFUywgMCwgNik7XHJcblx0XHQvLyB0aGlzLm91dHB1dC53aWR0aCA9IHRoaXMub3V0cHV0LnNjcm9sbFdpZHRoOyAvLyA/Pz9cclxuXHRcdC8vIHRoaXMub3V0cHV0LmhlaWdodCA9IHRoaXMub3V0cHV0LnNjcm9sbEhlaWdodDsgLy8gPz8/XHJcblx0XHQvLyBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn1cclxuXHJcblRyaXhpZS5lZmZlY3RzID0gRWZmZWN0cztcclxubW9kdWxlLmV4cG9ydHMgPSBUcml4aWU7XHJcbiJdfQ==
